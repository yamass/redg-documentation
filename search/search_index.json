{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RedG User Documentation","text":"<p>This is the user documentation for \"RedG\" (Ridiculously easy data Generation), a framework that simplifies and revolutionizes test data generation. If you are looking for the Javadoc, see here.</p>"},{"location":"#overview","title":"Overview","text":"<p>Take a look at our landing page for a quick overview. </p>"},{"location":"#quick-start","title":"Quick start","text":"<p>See here for a quick guide on how to setup RedG and integrate it into a Maven project.</p> <p>See here for other ways of integration RedG into your workflow.</p> <p>Read up on how to specify your test data with RedG.</p>"},{"location":"compatibility/","title":"Compatibility","text":"<p>RedG is able to work with the most common database systems. All you need is a JDBC driver. The Code Generator internally uses SchemaCrawler which supports a  wide range of database systems. You'll probably need an extra  SchemaCrawler plugin, so consult the table below or see Maven Central for a full list.</p> DBMS Necessary extra dependency Example project H2 Dependency included in RedG redg-examples/redg-example-h2 Oracle <code>us.fatehi:schemacrawler-oracle:15.01.06</code> redg-examples/redg-example-oracle IBM DB2 <code>us.fatehi:schemacrawler-db2:15.01.06</code> No example, support untested MS SQL Server\u00b9 <code>us.fatehi:schemacrawler-sqlserver:15.01.06</code> No example, support untested MySQL\u00b2 <code>us.fatehi:schemacrawler-mysql:15.01.06</code> redg-examples/redg-example-mysql MariaDB\u00b2 <code>us.fatehi:schemacrawler-mariadb:15.01.06</code> No example, untested, probably like MySQL PostgreSQL <code>us.fatehi:schemacrawler-postgresql:15.01.06</code> redg-examples/redg-example-postgres Sybase IQ <code>us.fatehi:schemacrawler-sybaseiq:15.01.06</code> No example, support untested <p>\u00b9 <sub><sup>You need to turn <code>QUOTED_IDENTIFIER</code> on or change the character to escape identifiers from double quotes to backticks by customizing the <code>JavaSqlStringEscapeMap</code>.</sup> \u00b2 <sub><sup>You need to either enable <code>ANSI</code> mode for the database or the connection or change the character to escape identifiers from double quotes to backticks by customizing the <code>JavaSqlStringEscapeMap</code>.</sup> <p>After the code is generated, it can be used to insert data into basically every DBMS with proper SQL support. When you insert the data directly with JDBC, the driver needs proper support for <code>setObject</code>, when generating SQL statements you might have to implement your own <code>InsertValuesFormatter</code>, so RedG uses the correct functions for e.g. string to date conversion.</p> <p>If you run into issues with a certain DBMS or just want to tell us that it works, feel free to open an issue or contact us.</p>"},{"location":"getting_started/","title":"Getting started","text":"<p>This chapter will guide you through your first project with RedG. You'll use RedG via the RedG Maven Plugin and integrate it  into a unit test.</p>"},{"location":"getting_started/#installation-and-configuration","title":"Installation and configuration","text":"<p>If your project can process Maven artifacts, the installation is quite straightforward. RedG is available on Maven Central. The newest stable version is 2.0 See here for an overview of all RedG Maven artifacts and the newest versions.</p>"},{"location":"getting_started/#maven","title":"Maven","text":"<p>Add the dependency for the <code>redg-runtime</code>. If you want to use the visualization feature to debug your application, include <code>jackson-core</code> and <code>jackson-databind</code>. Include <code>junit</code> for the unit tests.</p> <pre><code>&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;de.yamass.redg&lt;/groupId&gt;\n        &lt;artifactId&gt;redg-runtime&lt;/artifactId&gt;\n        &lt;version&gt;2.0&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;!-- optional, for visualization only --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n        &lt;version&gt;2.9.7&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n        &lt;version&gt;2.9.7&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;!-- for the unit tests --&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;junit&lt;/groupId&gt;\n        &lt;artifactId&gt;junit&lt;/artifactId&gt;\n        &lt;version&gt;4.11&lt;/version&gt;\n        &lt;scope&gt;test&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre> <p>Now include the RedG Maven Plugin (<code>redg-maven-plugin</code>) and configure it. You might also need a JDBC driver if you want the schema analysis to run against a database other than H2. This driver needs to be added as a plugin dependency, not as a project dependency.</p> <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;de.yamass.redg&lt;/groupId&gt;\n    &lt;artifactId&gt;redg-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.0&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;redg-generate&lt;/id&gt;\n            &lt;phase&gt;generate-test-sources&lt;/phase&gt; &lt;!-- This plugin generates sources for the test code --&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;redg&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;!-- Provide database connection information. We'll just use a H2 in-memory database here --&gt;\n                &lt;jdbcDriver&gt;org.h2.Driver&lt;/jdbcDriver&gt;\n                &lt;connectionString&gt;jdbc:h2:mem:redg&lt;/connectionString&gt;\n                &lt;username&gt;sa&lt;/username&gt;\n                &lt;password&gt;sa&lt;/password&gt;\n                &lt;!-- Alternative Oracle configuration:\n                &lt;jdbcDriver&gt;oracle.jdbc.OracleDriver&lt;/jdbcDriver&gt;\n                &lt;connectionString&gt;jdbc:oracle:thin:@localhost:1521:XE&lt;/connectionString&gt;\n                &lt;username&gt;system&lt;/username&gt;\n                &lt;password&gt;******&lt;/password&gt;\n                --&gt;\n                &lt;enableVisualizationSupport&gt;true&lt;/enableVisualizationSupport&gt; &lt;!-- if true, needs jackson dependencies --&gt;\n                &lt;sqlScripts&gt; &lt;!-- the SQL scripts to run before schema analysis --&gt;\n                    &lt;param&gt;src/test/resources/create-schema.sql&lt;/param&gt;\n                &lt;/sqlScripts&gt;\n                &lt;customTypeMappings&gt;src/test/resources/mappings.json&lt;/customTypeMappings&gt; &lt;!-- type mappings. Will be explained later --&gt;\n                &lt;schemaRegex&gt;REDG&lt;/schemaRegex&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n    &lt;dependencies&gt;\n        &lt;!-- JDBC driver and SchemaCrawler extension, only if not using H2. Entry depends on DBMS --&gt;\n        &lt;!-- Example for Oracle DB:\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.oracle&lt;/groupId&gt;\n            &lt;artifactId&gt;ojdbc6&lt;/artifactId&gt;\n            &lt;version&gt;11.2.0.3&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;us.fatehi&lt;/groupId&gt;\n            &lt;artifactId&gt;schemacrawler-oracle&lt;/artifactId&gt;\n            &lt;version&gt;15.01.06&lt;/version&gt;\n        &lt;/dependency&gt;\n        --&gt;\n    &lt;/dependencies&gt;\n&lt;/plugin&gt;\n</code></pre> <p>This is a minimal configuration for the Maven plugin. RedG will use an in-memory H2 database named <code>redg</code>. Before schema analysis the <code>create-schema.sql</code> script will be executed. This script will create the complete database schema. The plugin will analyze all tables within the <code>REDG</code> schema and generate code for these. </p> <p>The generated source code will have visualization support, so you can easily debug and visualize your test data.</p> <p>To show how the generated code can be customized, a custom type mapping is provided via a JSON file called <code>mappings.json</code>.</p> <p>For a detailed explanation of all parameters head over to here.</p> <p>Continue with the preparation after you're done here.</p>"},{"location":"getting_started/#gradle","title":"Gradle","text":"<p>Currently there is no Gradle plugin to generate the RedG entity code. See here for other ways to integrate the RedG code generator in your project.</p> <p>The RedG runtime can be included as a dependency.</p> <pre><code>dependencies {\n    testCompile group: 'de.yamass.redg', name: 'redg-runtime', version '2.0'\n\n    // optional, only for visualization support\n    testCompile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.9.7'\n    testCompile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.9.7'\n\n    // testing framework\n    testCompile group: 'junit', name: 'junit', version: '4.11'\n\n}\n</code></pre>"},{"location":"getting_started/#preparation","title":"Preparation","text":"<p>With RedG installed and set up, you can now prepare everything for the first code generation. If you followed the steps above, you'll need two more files before RedG can generate code for your database schema: <code>src/test/resources/create-schema.sql</code> and <code>src/test/resources/mappings.json</code>.</p>"},{"location":"getting_started/#sql-schema-script","title":"SQL Schema Script","text":"<p>In order to generate the code for the schema, RedG needs a live database running that schema. As this example uses a H2 in-memory database, all the tables have to be created first. Create the file <code>src/test/resources/create-schema.sql</code> and fill it with your DDL statements.</p> <p>If you don't yet have a database schema or just want to tets RedG, feel free to use this little demo schema:</p> <pre><code>CREATE SCHEMA REDG;\n\nCREATE TABLE REDG.DEMO_BANK_ACCOUNT (\n  BIC  VARCHAR2(11 CHAR) NOT NULL,\n  IBAN VARCHAR2(22 CHAR) NOT NULL,\n\n  CONSTRAINT pk_DEMO_BANK_ACCOUNT PRIMARY KEY (BIC, IBAN)\n);\n\nCREATE TABLE REDG.DEMO_COMPANY (\n  COUNTRY_CODE      VARCHAR2(2 CHAR)  NOT NULL,\n  NAME              VARCHAR2(30 CHAR) NOT NULL,\n  REGISTRATION_DATE TIMESTAMP,\n  ACC_BIC           VARCHAR2(11 CHAR) NOT NULL,\n  ACC_IBAN          VARCHAR2(22 CHAR) NOT NULL,\n\n  CONSTRAINT PK_DEMO_COMPANY PRIMARY KEY (COUNTRY_CODE, NAME),\n  CONSTRAINT FK_DEMO_COMPANY_BANK_ACC FOREIGN KEY (ACC_BIC, ACC_IBAN) REFERENCES DEMO_BANK_ACCOUNT (BIC, IBAN)\n);\n\nCREATE TABLE REDG.DEMO_USER (\n  ID            NUMBER(19)        NOT NULL,\n  USERNAME      VARCHAR2(30 CHAR) NOT NULL,\n  FIRST_NAME    VARCHAR2(50 CHAR),\n  LAST_NAME     VARCHAR2(50 CHAR),\n  WORKS_AT_CC   VARCHAR2(2 CHAR),\n  WORKS_AT_NAME VARCHAR2(30 CHAR),\n  ACC_BIC       VARCHAR2(11 CHAR) NOT NULL,\n  ACC_IBAN      VARCHAR2(22 CHAR) NOT NULL,\n  AGREED_TO_NEWSLETTER NUMBER(1),\n\n  CONSTRAINT pk_DEMO_USER PRIMARY KEY (ID),\n  CONSTRAINT fk_DEMO_USER_COMPANY FOREIGN KEY (WORKS_AT_CC, WORKS_AT_NAME) REFERENCES DEMO_COMPANY (COUNTRY_CODE, NAME),\n  CONSTRAINT fk_DEMO_USER_BANK_ACC FOREIGN KEY (ACC_BIC, ACC_IBAN) REFERENCES DEMO_BANK_ACCOUNT (BIC, IBAN)\n);\n</code></pre> <p>This SQL code will create a schema that looks like this:  The demo schema</p>"},{"location":"getting_started/#type-mappings","title":"Type Mappings","text":"<p>When analysing a database schema, RedG always tries to find an appropriate Java data type for a column. There are three cases, where this might not be enough:</p> <ul> <li>You want a different Java data type that still represents the same database data type (eg. <code>long</code> instead of <code>BigDecimal</code> for <code>NUMBER(10)</code>)</li> <li>RedG cannot understand the semantic meaning of a column data type (eg. <code>NUMBER(1)</code> or <code>CHAR(1)</code> for <code>boolean</code>)</li> <li>You want to plug in a custom, maybe even far more complex, data type and use it instead of the default types</li> </ul> <p>If this happens, you can create a custom type mapping. When using the Maven plugin, you can simply specify that type mapping in a JSON file. For the demo schema from above you can use the following type mapping and save it in the file <code>src/test/resources/mappings.json</code>:</p> <pre><code>{\n  \"REDG.DEMO_USER\": {\n    \"ID\": \"Long\",\n    \"AGREED_TO_NEWSLETTER\": \"Boolean\"\n  },\n  \"REDG.DEMO_COMPANY\": {\n    \"ID\": \"Long\",\n    \"REGISTRATION_DATE\": \"java.time.LocalDateTime\"\n  }\n}\n</code></pre> <p>In this example, the <code>DEMO_USER</code> table gets its <code>ID</code> mapped as a <code>Long</code> (always use wrapper classes, not primitive types) and <code>AGREED_TO_NEWSLETTER</code> as a <code>Boolean</code>.  The <code>DEMO_COMPANY</code> gets the same mapping for the <code>ID</code> and gets the <code>REGISTRATION_DATE</code> as a <code>LocalDateTime</code>. For each class not in <code>java.lang</code> you have to provide the fully qualified class name.</p> <p>If your JDBC driver is not able to perform the transformations you want (<code>Boolean</code> to <code>NUMBER(1)</code> or <code>LocalDateTime</code> to <code>TIMESTAMP</code>), you have to provide a custom <code>PreparedStatementParameterSetter</code> during test runtime. If you want to generate SQL statements, you might need a custom <code>SQLValuesFormatter</code> during test runtime.</p>"},{"location":"getting_started/#code-generation","title":"Code generation","text":"<p>By now everything is ready for the first round of code generation. If you are using Maven, either run your whole test-suite with <code>mvn test</code> or just RedG with <code>mvn redg:redg@redg-generate</code>. If you are using Gradle, run your custom solution or wait until the release of the Gradle plugin. If no error occured, you should find the generated sources in <code>target/generated-test-sources/redg</code>.</p> <p> The generated code</p>"},{"location":"getting_started/#test-data-specification","title":"Test Data Specification","text":"<p>Now that RedG has generated the entity classes, you can create a RedG instance.  A good approach is to create a factory that will create <code>RedG</code> instances, so you don't have to configure the RedG instance every time you need one. </p> <p>An example for some test data:</p> <pre><code>public class MyRedGFactory {\n\n    public RedG createRedG() {\n        RedG redG = new RedG();\n        redG.setDefaultValueStrategy(createDefaultValueStrategy());\n        return redG;\n    }\n\n    private DefaultValueStrategy createDefaultValueStrategy() {\n        DefaultValueStrategyBuilder builder = new DefaultValueStrategyBuilder();\n\n        builder.whenColumnNameMatches(\"ID\")\n                .thenUseProvider(new IncrementingNumberProvider());\n        builder.whenTableNameMatches(\".*CARD\").andColumnNameMatches(\"TYPE\")\n                .thenUse(\"MASTERCARD\");\n        builder.when(columnModel -&gt; columnModel.getDbFullTableName().equals(\"CCM.CREDITCARD.UUID\"))\n                .thenCompute((columnModel, expectedType) -&gt; UUID.randomUUID().toString());\n        // ...\n\n        return builder.build();\n    }\n}\n</code></pre> <p>Now you can model your test data. You might end up inlining the test data into your unit tests if it is not too complex. To make RedG insert the modeled data into the database, call <code>AbstractRedG.insertDataIntoDatabase(...)</code>. In most cases this dead simple approach is all you need. </p> <p>Example:</p> <pre><code>import ...;\n\npublic class DemoTest {\n\n    @Test\n    public void testStuff() throws Exception {\n\n        // instantiate RedG\n        RedG redG = new MyRedGFactory().createRedG();\n\n        // create some test data \n        GDemoBankAccount companyBankAccount = redG.addDemoBankAccount()\n                .iban(\"DE13109817441665870952\");\n        GDemoCompany smallCompany = redG.addDemoCompany(companyBankAccount)\n                .countryCode(\"DE\")\n                .name(\"Spielwarenfachgesch\u00e4ft M\u00fcller\");\n        redG.addDemoUser(redG.dummyDemoBankAccount)\n                .username(\"Diana_Dummy\")\n                .company(smallCompany);\n\n        // insert the data into the database using a javax.sql.DataSource\n        new DemoTestData().getDataSet().insertDataIntoDatabase(dataSource); \n\n        // perform your actual test against the database...\n        ...\n    }\n\n}\n</code></pre>"},{"location":"getting_started/#debugging-with-the-visualizer","title":"Debugging with the visualizer","text":"<p>If your generated RedG entity classes have the visualization support enabled, debugging RedG is extremely simple and comfortable. Add a breakpoint wherever you want to inspect the current RedG dataset and let the code run until there. Once it reached the breakpoint, evaluate the <code>getVisualizationJson()</code> method on your RedG main object. This method will return a big JSON string. Copy it into your clipboard or export it into a file and paste/drag it into the RedG Visualizer.</p>"},{"location":"specifying_test_data/","title":"Specifying test data","text":"<p>With RedG you specify all your test data in pure Java code. And \"all your test data\" means  \"only the data you really need\". RedG takes care of all the other stuff (like not specified <code>NOT NULL</code> fields, required foreign key relations etc.).</p>"},{"location":"specifying_test_data/#general-api-design","title":"General API design","text":"<p>The entity classes RedG generates use a fluent interface with getters and setters in \"JQuery style\" (no <code>get</code>/<code>set</code> prefix, calling without parameter gets the value, with parameter sets it).</p> <p>RedG  always generates a \"main class\" (or \"manager class\"). This is not an executable class containing a  <code>public static void main(String[] args)</code>, but the class you'll use to create and manage your RedG entities (and thus your test data). This class is usually named <code>RedG</code>.</p> <p>Using the RedG main class you can create entities. An entity is a java object that represents one row of data that will be inserted into a database (or already exists in the database). Usually you can use methods to change fields (\"columns\" in your database) on these entities.</p>"},{"location":"specifying_test_data/#adding-an-entity","title":"Adding an entity","text":"<p>To create a new entity and add it to RedG's internal list of objects to insert call one of the <code>add...()</code> methods on a RedG object. Replace <code>...</code> with the name of the entity you want to add. If the entity has required fields (either <code>NOT NULL</code> foreign keys or columns / foreign keys marked as explicit)  you'll need to pass them to the method. Passing a <code>null</code> value will result in a <code>NullPointerException</code>.</p> <p>Once you have created your entity you can use it's setters to set the values for the necessary fields.</p> <p>Example:</p> <pre><code>RedG redG = new RedG();\n// or when customizing many internal things, consider using the RedGBuilder class\n// RedG redG = new RedGBuilder&lt;RedG&gt;().build();\n\n// either \nGTeacher mathTeacher = redG.addTeacher()\n    .name(\"Leonhard Euler\")\n    .age(310);\n\n// or just\nredG.addTeacher()\n    .name(\"Isaac Newton\");\n\n// or even\nGTeacher chemistryTeacher = redG.addTeacher();\nchemistryTeacher\n    .name(\"Niels Bohr\")\n    .hasNobelPrice(true)\n</code></pre> <p>When you do not need an entity for further foreign key relations or data manipulation, there is no need to save it  in a variable.</p> <p>As you can see in the example, different fields are set for <code>mathTeacher</code> and <code>chemistryTeacher</code> although they are of the same  type and have the same columns. Even if <code>age</code> or <code>hasNobelPrice</code> would both be mandatory (<code>NOT NULL</code>) this code would still work, as RedG generates default values for all fields that are not specified by the user.</p> <p>Example for entities with <code>NOT NULL</code> foreign key or explicit attributes:</p> <pre><code>// name of school is an explicit attribute for demonstration purposes\nredG.addSchool(\"Time-traveling School with famous teachers\")\n    .headmaster(einstein);\n\n// Every class needs a teacher, so it is specified at creation time and may not be null\nGClass chemistryClass = redG.addClass(chemistryTeacher)\n    .name(\"Chemistry 101\")\n    .maxStudentCount(45)\n</code></pre>"},{"location":"specifying_test_data/#generating-a-dummy-entity","title":"Generating a dummy entity","text":"<p>There are many scenarios where you need to test a specific entity but only need some or none of its dependencies. With most other tools you would have to specify each and every dependency (and their dependencies and so on) and  you could wind up with far too much code/XML for just one entity.</p> <p>To solve this problem RedG offers a dummy entity generator, that will generate a valid dummy entity for you. This entity will have meaningless values but is still a valid entity that can be referenced wherever you want.</p> <p>To stay in the educational environment with this example, imagine a test case where you need to test the <code>SCHOOL_SUBJECT</code> table (<code>SchoolSubject</code> entity name, <code>GSchoolSubject</code> entity class name). Every subjects needs a teacher. A teacher is a human with a pay grade, a qualification and a school he graduated from (All of these have to be provided because of constraints  on the database). Every subjects needs one required textbook as well.</p> <pre><code>// Without dummy entities and without the previously defined entities\n\nGSchool school = redG.addSchool(\"Wherever Primary School\");\nGHuman somePerson = redG.addHuman();\nGTeacher someTeacher = redG.addTeacher(somePerson, Paygrade.TEACHER, \n    Qualifications.NONE, school);\nGTextBook textBook = redG.addTextBook();\n\nGSchoolSubject aqm = redg.addSchoolSubject(someTeacher, textBook)\n    .name(\"Advanced quantum mechanics\")\n    .isCoreClass(true)\n    .room(\"1.42\");\n\n// with RedGs dummy generator\n\nGSchoolSubject aqm = redG.addSchoolSubject(\n        redG.dummyTeacher(),\n        redG.dummyTextBook()\n)\n    .name(\"Advanced quantum mechanics\")\n    .isCoreClass(true)\n    .room(\"1.42\");\n</code></pre>"},{"location":"specifying_test_data/#referencing-existing-entities","title":"Referencing existing entities","text":"<p>Depending on your setup you might already have some data in your database before running RedG and need to reference these data for a foreign key relation within RedG.</p> <p>RedG allows you to specify that a certain entity is already present in the database. When inserting you test data RedG will test that the specified entity is really already in the database.</p> <p>To reference an existing entity, use the <code>existing...()</code> methods of the RedG object. You have to pass the full primary key as the arguments to these methods. If a table does not have primary keys, you cannot reference it.</p> <p>Example:</p> <pre><code>GTeacher euklid = redG.existingTeacher(4); // 4 is value of primary id column\n\n// use euklid just like normal for references, just don't try to modify him or read values other the primary keys\n\n// trying to modify fields will throw an UnsupportedOperationException\neuklid.isDead(false); \n\nredG.addMemorialDay(euklid) // works just like expected\n</code></pre>"},{"location":"specifying_test_data/#self-references-circular-dependencies","title":"Self-references / Circular dependencies","text":"<p>RedG supports self-references via the <code>RedG#entitySelfReference()</code> method. If you have a schema like</p> <pre><code>create table TREE_ELEMENT (\n  ID number(19) not null primary key,\n  VALUE varchar2(50 char),\n  PARENT_ID number(19) not null,\n\n  constraint FK_TREE_ELEMENT_PARENT foreign key (PARENT_ID) REFERENCES TREE_ELEMENT(ID)\n);\n</code></pre> <p>you can simply create a root element referencing itself as the parent with <code>redg.addTreeElement(redg.entitySelfReference()).value(\"Root\")</code>.</p> <p>Other circular references and dependencies are currently not supported by RedG. If you really do need this, the best way would be to break open the circle in one place in the specified test data and then \"close\" the circle with a manual INSERT after you inserted the test data.</p>"},{"location":"about/imprint/","title":"Imprint / Impressum","text":"<p>Responsible for the content of this webpage is / (Verantwortlich f\u00fcr den Inhalt dieses Internetauftrittes ist)</p> <p>Yann Massard E-Mail:  yamass@gmail.com</p>"},{"location":"about/imprint/#privacy-policy-datenschutzerklarung","title":"Privacy Policy / Datenschutzerkl\u00e4rung","text":"<p>This website does not collect, process or store personal information about users on this site.</p> <p>Diese Webseite sammelt, verarbeitet oder speichert keine Daten \u00fcber Nutzerverhalten auf dieser Seite.</p>"},{"location":"about/license/","title":"License","text":"<p>This page provides a quick overview of the different open source licenses used by the RedG projects.</p> <p>Note</p> <p>This is only an overview. For detailed information, check out the <code>LICENSE</code> (or <code>LICENSE.txt</code>) file in the code repositories.</p>"},{"location":"about/license/#redg-library","title":"RedG library","text":"<p>The main RedG library is available under the Apache 2.0 License.</p>"},{"location":"about/license/#redg-visualizer","title":"RedG visualizer","text":"<p>The RedG visualizer tool is available under the Apache 2.0 License.</p>"},{"location":"about/license/#redg-documentation","title":"RedG documentation","text":"<p>Unless stated otherwise, this whole documentation is licensed under a  Creative Commons Attribution-ShareAlike 4.0 International License</p>"},{"location":"customization/generator/convenience_setters/","title":"Convenience setter methods","text":"<p>This feature of RedG allows you to add convenience setters to the generated entity classes. For example an entity with a <code>java.sql.Timestamp</code> field could get an extra setter for better date types  (like <code>java.time.LocalDatetime</code>). All you have to provide is a conversion method that can convert from the convenient  data type to the needed type. This conversion method needs to be a public static method taking exactly two parameters:</p> <ul> <li>The value for the attribute (as the convenient type)</li> <li>The class (<code>Class&lt;?&gt;</code>) of the required type</li> </ul> <p>It needs to return an instance of the class that was passed as a second parameter. Using generics, the method  signature for a conversion method that transforms a string into some kind of date could be  <code>public static &lt;T&gt; T convertToDate(String s, Class&lt;T&gt; clazz)</code>.</p> <p>The RedG runtime provides a converter that can convert a ISO-8601 formatted string into basically every Java date type (<code>java.util.Date, java.sql.Date, Time, Timestamp, LocalTime, LocalDate, LocalDateTime, ZonedDateTime, OffsetDateTime, OffsetTime</code>). To use it, specify <code>de.yamass.redg.runtime.util.DateConverter.convertDate</code> as the fully qualified converter method name.</p>"},{"location":"customization/generator/convenience_setters/#xml-file","title":"XML file","text":"<p>Use the <code>XmlFileConvenienceSetterProvider</code> class to load your XML file.</p> <p>In the XML you can specify multiple convenience setters for each original data type. The example XML specifies that every attribute of the type <code>java.util.Date</code> gets another setter accepting a <code>java.lang.String</code> and converting this string into a date with the <code>de.yamass.redg.runtime.util.DateConverter.convertDate</code> method.</p> <p>If you want to restrict the convenience setters to certain tables / columns, you have to provide a  custom implementation.</p> <pre><code>&lt;convenienceSetterConfig&gt;\n   &lt;javaType name=\"java.util.Date\"&gt;\n       &lt;convenienceSetter setterJavaTypeName=\"java.lang.String\" fullyQualifiedConverterMethodName=\"de.yamass.redg.runtime.util.DateConverter.convertDate\"/&gt;\n   &lt;/javaType&gt;\n&lt;/convenienceSetterConfig&gt;\n</code></pre>"},{"location":"customization/generator/convenience_setters/#java-api","title":"Java API","text":"<p>Your custom implementation has to implement the <code>ConvenienceSetterProvider</code> interface. You can then decide for each  column on every table what convenience setters should be added. If you do not want any convenience setters, return an  empty list or fall back to a <code>DefaultConvenienceSetterProvider</code>. Please always use the <code>javaDataTypeName</code> parameter as the required parameter type and not the type according to the <code>column</code>, as your type mapping might have changed the type that the database analysis framework suggested.</p> <pre><code>public interface ConvenienceSetterProvider {\n\n    List&lt;ConvenienceSetterModel&gt; getConvenienceSetters(Column column, String javaDataTypeName);\n\n}\n</code></pre>"},{"location":"customization/generator/explicit_attributes/","title":"Explicit attributes &amp; foreign keys","text":"<p>Explicit attributes and explicit foreign keys can be used to \"mark\" certain attributes / foreign keys as required. </p> <p>If you mark a foreign key as explicit it is treated as a <code>NOT NULL</code> foreign key. This allows you to treat foreign keys that are meant to be <code>NOT NULL</code>  but are nullable for some reason (legacy schema, cyclic dependencies, whatever) as <code>NOT NULL</code> within RedG and make them required for entity creation.</p> <p>If you mark an attribute as explicit, it gets treated like a <code>NOT NULL</code> foreign key. This means, that a value has to be set for this attribute at entity creation time and no default value will be used for this attribute. Use this feature sparingly, as using it everywhere defeats the purpose of RedGs default value system.</p>"},{"location":"customization/generator/explicit_attributes/#json-file","title":"JSON file","text":"<p>Load your JSON files with the <code>JsonFileExplicitAttributeDecider</code>. </p> <p>The structure of the JSON input can be found below. </p> <p>Regex support</p> <p>All strings in this JSON file will be evaluated as regualr expressions and matched against the table / column / foreign key names. Remember to escape certain characters with a backslash (\"\\\") if you want the literal character to match.</p> <pre><code>{\n  \"TABLENAME\": {\n    \"attributes\": [\"ATTRIBUTE1\", \"ATTRIBUTE2\"],\n    \"relations\": [\n      [\"FOREIGN_KEY_1_COLUMN_1\", \"COLUMN2\"],\n      [\"FOREIGN_KEY_2_PART_1\", \"OTHER_PART2\"]\n    ]\n  }\n}\n</code></pre>"},{"location":"customization/generator/explicit_attributes/#java-api","title":"Java API","text":"<p>If you want to roll your own implementation, simply implement <code>ExplicitAttributeDecider</code> and decide for each column / attribute and foreign key whether it  should be explicitly required or not.</p> <pre><code>public interface ExplicitAttributeDecider {\n\n    boolean isExplicitAttribute(Column column);\n\n    boolean isExplicitForeignKey(ForeignKey foreignKey);\n\n}\n</code></pre>"},{"location":"customization/generator/name_mapping/","title":"Custom name mapping","text":"<p>The custom name mapping allows you to change how RedG names the entity classes and their methods. In many cases and when using pretty default SQL names no intervention is needed here.</p> <p>The default naming behaviour of RedG is described below:</p> Type Behaviour Example Tables Split by underscore into words. Make words lowercase with first letter uppercase and join them together, thus creating a uppercase camel-case name. DEMO_USER \u2192 DemoUser Columns Split by underscore into words. Make words lowercase with first letter uppercase and join them together. First word starts lowercase, thus creating a lowercase camel-case name. FIRST_NAME \u2192 firstName Foreign Key Split by underscore into words. Remove \"FK\" and name of own table. Build lowercase camel-case name of remaining words. FK_USER_WORKS_AT_COMPANY \u2192 worksAtCompany Incoming Foreign Key Name of the referencing table + \"sFor\" + Name for foreign key"},{"location":"customization/generator/name_mapping/#json-file","title":"JSON file","text":"<p>Use the <code>JsonFileNameProvider</code> when specifying name mappings in a JSON file. The Maven plugin has built-in support for JSON files. Getting names for incoming foreign keys from JSON files is not supported yet and RedG will fall back to the <code>DefaultNameProvider</code>.</p> <p>See below for the syntax of the JSON file:</p> <pre><code>{\n  \"TABLE_NAME\": {\n    \"name\": \"TableClassName\",\n    \"columns\": {\n      \"COLUMN_1\": \"myCustomNameCol1\",\n      \"COLUMN_2\": \"otherCustomName\",\n      \"FK_SPECIAL_FOREIGN_KEY\": \"customFkName\"\n    }\n  }\n}\n</code></pre>"},{"location":"customization/generator/name_mapping/#java-api","title":"Java API","text":"<p>Custom implementations have to implement the <code>NameProvider</code> interface. If you only want to override behaviour for one type (table, column, foreign key), consider returning <code>null</code> for all methods you do not want to override and use a <code>MultiProviderNameProvider</code>.</p> <pre><code>public interface NameProvider {\n\n    String getClassNameForTable(Table table);\n\n    String getMethodNameForColumn(Column column);\n\n    String getMethodNameForForeignKey(ForeignKey foreignKey);\n\n    String getMethodNameForIncomingForeignKey(ForeignKey foreignKey);\n}\n</code></pre>"},{"location":"customization/generator/type_mapping/","title":"Custom type mapping","text":"<p>RedG allows you to customize the SQL to Java type mapping for the generated entity classes. When analysing a database schema, RedG always tries to find an appropriate Java datatype for a column.  There are three cases, where this might not be enough:</p> <ul> <li>You want a different Java datatype that still represents the same database datatype (eg. <code>long</code> instead of <code>BigDecimal</code> for <code>NUMBER(10)</code>)</li> <li>RedG cannot understand the semantic meaning of a column datatype (eg. <code>NUMBER(1)</code> or <code>CHAR(1)</code> for <code>boolean</code>)</li> <li>You want to plug in a custom, maybe even far more complex, data type and use it instead of the default types</li> </ul> <p>If this happens, you can create a custom type mapping. The following sections describe how to specify your custom mapping.</p>"},{"location":"customization/generator/type_mapping/#json-file","title":"JSON file","text":"<p>If you want to specify your mapping in a JSON file, use the <code>JsonFileDataTypeProvider</code>. The  Maven plugin has built-in support for JSON files.</p> <p>The syntax for the JSON file is simple: You can specify <code>tableMappings</code> that specify the type for a column inside a table or you can use the <code>defaultMappings</code> where you can assign a data type to be used for a specific SQL type. The <code>tableMappings</code> have a higher priority and can be  used to override the <code>defaultMappings</code>.</p> <p>For the <code>tableMappings</code>: Each table gets an own object. The key for that object is the full table name  (including the schema name). This object contains a key for each column you want to map. The key is the column name.  The value for each key is the wanted data type.</p> <p>For the <code>defaultMappings</code>: The key is the SQL data type (with or without precision information), the value is the Java type. SQL types with precision information always take precedence over types without precision information. So when a column has the data type <code>NUMBER(1)</code> and the mappings contain both <code>NUMBER -&gt; Long</code> and <code>NUMBER(1) -&gt; Boolean</code> the column will be mapped to a <code>Boolean</code> type. When dealing with <code>VARCHAR</code>s or similar, you can also use \"precision\" (aka length) information, but do not include <code>CHAR</code> inside the brackets (eg. if type is <code>VARCHAR2(100 CHAR)</code>, use <code>VARCHAR2(100)</code> to match this).</p> <p>Example:</p> <pre><code>{\n  \"tableMappings\": {\n    \"SCHEMA-NAME.TABLE-NAME\": {\n      \"COLUMN-NAME\": \"your.java.Datatype\",\n      \"OTHER-COLUMN\": \"other.Type\"\n    },\n    \"SCHEMA-NAME.OTHER-TABLE\": {\n      \"ID-COLUMN\": \"long\"\n    }\n  },\n  \"defaultMappings\": {\n    \"NUMBER\": \"java.lang.Long\",\n    \"NUMBER(1)\": \"java.lang.Boolean\"\n  }\n}\n</code></pre>"},{"location":"customization/generator/type_mapping/#xml-file","title":"XML file","text":"<p>If you want to specify your type mapping with an XML file, use the <code>XmlFileDataTypeProvider</code>. The  Maven plugin has built-in support for XML files. </p> <p>The root element is <code>&lt;typeMappings&gt;</code>. This element has a child <code>&lt;tableTypeMappings&gt;</code>. Each table you want to specify the types for gets a <code>&lt;table&gt;</code> element with a <code>name</code> attribute specifying the table name.  Each table element has <code>&lt;column&gt;</code> child elements. These elements have a <code>name</code> attribute and their value is the wanted data type.</p> <p>The other allowed child element is <code>&lt;defaultTypeMappings&gt;</code>. It can have multiple <code>&lt;type&gt;</code> children with a <code>sql</code> attribute specifying the SQL data  type (with precision support just like for JSON). The value of this node is the Java type that the SQL type should be mapped to.</p> <p>Example:</p> <pre><code>&lt;typeMappings&gt;\n   &lt;tableTypeMappings&gt;\n       &lt;table name=\"TABLE_NAME\"&gt;\n            &lt;column name=\"COLUMN_NAME\"&gt;java.lang.String&lt;/column&gt;\n       &lt;/table&gt;\n   &lt;/tableTypeMappings&gt;\n   &lt;defaultTypeMappings&gt;\n       &lt;type sql=\"DECIMAL(1)\"&gt;java-lang.Boolean&lt;/type&gt;\n   &lt;/defaultTypeMappings&gt;\n&lt;/typeMappings&gt;\n</code></pre>"},{"location":"customization/generator/type_mapping/#java-api","title":"Java API","text":"<p>Custom implementations have to implement the <code>DataTypeProvider</code> interface. The method <code>getCanonicalDataTypeName</code> gets called for each column in every table. The method has to return a fully qualified class name that should be used for that column.</p> <pre><code>public interface DataTypeProvider {\n    String getCanonicalDataTypeName(Column column);\n}\n</code></pre>"},{"location":"customization/runtime/default_value_strategy/","title":"DefaultValueStrategy","text":"<p>The default value strategy is one of RedGs most important features, and like most of RedG can be customized to fit your  requirements. </p> <p>The default implementation is <code>DefaultDefaultValueStrategy</code>. It delivers null for any nullable columns and a fixed non-null  value for <code>NOT NULL</code> columns. However, most of the time, the <code>DefaultDefaultValueStrategy</code> will not completely meet your needs. </p> <p>You could easily write your own <code>DefaultValueStrategy</code> from scratch, but we recommend using the <code>DefaultValueStrategyBuilder</code>. It provides a convenient and clear API for creating custom <code>DefaultValueStrategy</code>s.</p>"},{"location":"customization/runtime/default_value_strategy/#defaultdefaultvaluestrategy","title":"DefaultDefaultValueStrategy","text":"<p>RedG's default default value strategy supports the following data types and provides a fixed default value for them.</p> Data type Default value <code>String</code> <code>\"-\"</code> (Oracle does not support empty Strings and treats them as <code>NULL</code>) <code>char</code> / <code>Character</code> <code>' '</code> (whitespace character) <code>boolean</code> / <code>boolean</code> <code>false</code> everything extending <code>Number</code> / primitive number types <code>0</code> everything extending <code>java.util.Date</code> <code>0</code> (= <code>01.01.1970</code>) Java 8 date types <code>1970-01-01T00:00:00.000Z</code> <p>If a column is a primary key or has a unique constraint, a value that is unique to that column  (but may be the same as in other unique columns) is generated.</p> Data type Unique default value Max number of unique values <code>String</code> <code>\"A\"</code>, <code>\"B\"</code>, ..., <code>\"Z\"</code>, <code>\"AA\"</code>, <code>\"AB\"</code> ... 2^64 <code>char</code> / <code>Character</code> Unicode Character starting with <code>\\u0001</code> up until <code>\\uffff</code> (2^16)-1 = 65,535 <code>boolean</code> / <code>boolean</code> <code>false</code>, then <code>true</code> 2 everything extending <code>Number</code> / primitive number types <code>0</code>, <code>1</code>, <code>2</code>, ... 2^64 everything extending <code>java.util.Date</code> Counting up milliseconds since unix epoch, starting at <code>0</code> until year 8099 Java 8 date types Counting up milliseconds since unix epoch, starting at <code>0</code> until year 8099"},{"location":"customization/runtime/default_value_strategy/#defaultvaluestrategybuilder","title":"DefaultValueStrategyBuilder","text":"<p><code>DefaultValueStrategyBuilder</code> is the recommended way of creating <code>DefaultValueStrategy</code>s. It provides a convenient and clear API for creating <code>DefaultValueStrategy</code>s. </p> <pre><code>DefaultValueStrategyBuilder builder = new DefaultValueStrategyBuilder();\n\nbuilder.whenColumnNameMatches(\"ID\")\n        .thenUseProvider(new IncrementingNumberProvider());\nbuilder.whenTableNameMatches(\".*CARD\").andColumnNameMatches(\"TYPE\")\n        .thenUse(\"MASTERCARD\");\nbuilder.when(columnModel -&gt; columnModel.getDbFullTableName().equals(\"CCM.CREDITCARD.UUID\"))\n        .thenCompute((columnModel, expectedType) -&gt; UUID.randomUUID().toString());\n\nbuilder.build();\n</code></pre> <p>By default <code>DefaultValueStrategyBuilder</code> will add a <code>DefaultDefaultValueStrategy</code> as fallback value provider. However, you can change this using  <code>DefaultValueStrategyBuilder.setFallbackStrategy(DefaultValueStrategy)</code>.</p>"},{"location":"customization/runtime/default_value_strategy/#pluggabledefaultvaluestrategy","title":"PluggableDefaultValueStrategy","text":"<p>This is the <code>DefaultValueStrategy</code> implementation that the <code>DefaultValueStrategyBuilder</code> uses internally.</p> <p>The <code>PluggableDefaultValueStrategy</code> has a list of <code>PluggableDefaultValueProvider</code>s. When a default value needs to be generated, it checks whether a provider can provide a default value for the required data type / table / column.  The values from all eligible providers are then collected and the first not-null value is returned as the default value. If no eligible provider is found or all return <code>null</code>, <code>null</code> gets returned. Even if the column is nullable  (<code>notNull == false</code>), a not-null value is preferred.</p> <p>The following providers are bundles with RedG:</p> Class name Description <code>ConstantStringProvider</code> Provides a constant String which can be set by the user. <code>ConstantValueProvider</code> Provides a constant value for a certain data type. Returns the value if <code>value.getClass()</code> equals the exact required type. <code>StaticNumberProvider</code> Provides a static number. <code>IncrementingNumberProvider</code> Provides an incrementing number. The start value can be specified. The counter is incremented for each column separately. Ideal for index columns. <code>StaticDateProvider</code> Takes a <code>java.util.Date</code> as a parameter and returns it for every java date type. <code>CurrentDateProvider</code> Returns the current date / time for every java date type. <code>ConditionalProvider</code> Encapsulates another provider and will only return its value if the regular expressions for table &amp; column name match. <code>CustomConditionalProvider</code> A conditional provider that is even more flexible that the <code>ConditionalProvider</code>. Is used by the builder system. <code>DefaultDefaultValueProvider</code> A provider encapsulating the <code>DefaultDefaultValueStrategy</code>. Use for fallback purposes."},{"location":"customization/runtime/default_value_strategy/#custom-provider-implementation","title":"Custom provider implementation","text":"<p>Implementing a custom provider is easy. Simply implement the <code>PluggableDefaultValueProvider</code> interface and implement both the <code>getDefaultValue</code> and <code>willProvide</code> method. The <code>willProvide</code> method should return <code>true</code> if <code>getDefaultValue</code> can and should produce a default value for the current column and data type.</p>"},{"location":"customization/runtime/default_value_strategy/#custom-implementation","title":"Custom implementation","text":"<p>Custom default value strategies have to implement the <code>DefaultValueStrategy</code> interface.</p> <p>If <code>notNull</code> is <code>true</code> and <code>null</code> is returned, RedG will fail. RedG does not perform further checks on the value generated by this method. You have full control and responsibility.</p> <pre><code>public interface DefaultValueStrategy {\n    &lt;T&gt; T getDefaultValue(ColumnModel columnModel, Class&lt;T&gt; type);\n}\n</code></pre>"},{"location":"customization/runtime/dummy_factory/","title":"Dummy factory","text":"<p>This section describes how to modify the default behaviour of RedG's dummy data generation mechanism. For an explanation  and a guide on how to use this mechanism, check this out.</p> <p>There are two main reasons to modify or extend the existing dummy generation system:</p> <ul> <li>You want to modify the generated dummy entities</li> <li>RedG cannot generate the dummy entities for some reason</li> </ul> <p>If the latter occurs, feel free to open an issue and we might try to  implement support for your case.</p>"},{"location":"customization/runtime/dummy_factory/#implement-own-dummyfactory","title":"Implement own DummyFactory","text":"<p>If you need to, you can always implement your own <code>DummyFactory</code>. Here are a few tips when implementing your custom factory:</p> <ul> <li>Remember to take care of all transitive dependencies.</li> <li>Abstain from using user-generated entities already within RedG as dummies. Dummies should be entities your factory generated.</li> <li>Implement <code>isDummy</code> correctly, or features like the visualization will not work properly.</li> </ul> <pre><code>public interface DummyFactory {\n\n    &lt;T extends RedGEntity&gt; T getDummy(AbstractRedG redG, Class&lt;T&gt; dummyClass);\n\n    boolean isDummy(RedGEntity entity);\n}\n</code></pre>"},{"location":"customization/runtime/prepared_statement_parameter_setter/","title":"PreparedStatement parameter setter","text":"<p>The PreparedStatement parameter setter is used by RedG set the column values for the <code>PreparedStatement</code>. It can be used to convert a custom data type into a type the JDBC driver can understand.</p> <p>Note</p> <p>If you are not using PreparedStatements with the <code>insertDataIntoDatabase()</code> method, you can ignore the PreparedStatement parameter setter and take a look at the  SQL values formatter</p>"},{"location":"customization/runtime/prepared_statement_parameter_setter/#default-preparedstatement-parameter-setter","title":"Default PreparedStatement parameter setter","text":"<p>The <code>DefaultPreparedStatementSetter</code> only calls <code>toString()</code> on the value if the JDBC type is one of  <code>Types.CHAR, Types.VARCHAR, Types.LONGNVARCHAR</code>. Every other value is passed to the statement without modification.</p> <p>This works for most standard java types and depending on your JDBC driver it might even work for the new Java time  types. Consult the documentation of your JDBC driver for more information on supported types.</p>"},{"location":"customization/runtime/prepared_statement_parameter_setter/#java-api","title":"Java API","text":"<p>If you need to implement your own setter, implement the <code>PreparedStatementParameterSetter</code> interface.</p> <p>Inside of this method you should transform the object if needed. The <code>AttributeMetaInfo</code> provide you with metadata about the object you are processing. After transforming the object, set it as the parameter on the passed <code>statement</code>.</p> <p>Caution</p> <p>Only call <code>statement.set...()</code> with the index parameter specified in <code>parameterIndex</code>. RedG performs no further checks whether you actually set the right parameter (or any at all).</p> <pre><code>@FunctionalInterface\npublic interface PreparedStatementParameterSetter {\n\n    void setParameter(PreparedStatement statement, int parameterIndex, Object object, AttributeMetaInfo attributeMetaInfo, final Connection connection) throws SQLException;\n}\n</code></pre>"},{"location":"customization/runtime/sql_values_formatter/","title":"SQL values formatter","text":"<p>The SQL values formatter defines how attribute / column values have to be represented in the SQL <code>INSERT</code> string generated by RedG. RedG offers a default formatter <code>DefaultSQLValuesFormatter</code> that can turn the most common data  types into valid SQL. If you are using uncommon or custom data types, you have to provide your own implementation.</p> <p>Note</p> <p>If you are not generating SQL <code>INSERT</code> statements with the <code>generateSQLStatements()</code> method, you can ignore the SQL values formatter and take a look at the  PreparedStatement parameter setter</p>"},{"location":"customization/runtime/sql_values_formatter/#default-sql-values-formatter","title":"Default SQL values formatter","text":"<p>The default formatter provided by RedG formats the input like described in the following table. (Empty fields in the  type columns mean that RedG does not check that type)</p> SQL type Java type Formatting <code>VARCHAR</code> &amp;<code>VARCHAR2</code> <code>toString()</code> gets called on value and single quotation marks get escaped. Escaped string gets wrapped in single quotation marks. <code>DECIMAL</code> &amp; <code>NUMBER</code> Boolean <code>1</code> for <code>true</code>, <code>0</code> for false. <code>DECIMAL</code> &amp; <code>NUMBER</code> <code>toString()</code> gets called on value. This works for numbers, as they all implement a correct toString() method. No precision checks are performed. <code>java.util.Date</code> A timestamp gets constructed from the unix timestamp and inserted as a string using the <code>TO_TIMESTAMP(string, format)</code> SQL function. <code>TemporalAccessor</code> The temporal value gets formatted and inserted as a string using the <code>TO_TIMESTAMP(string, format)</code> SQL function."},{"location":"customization/runtime/sql_values_formatter/#java-api","title":"Java API","text":"<p>If you need your own formatter, simply implement the <code>SQLValuesFormatter</code> interface. The <code>formatValues</code> method gets called for every value that has to be formatted (so every attribute in every entity).</p> <pre><code>public interface SQLValuesFormatter {\n\n    &lt;T&gt; String formatValue(T value, String sqlDataType, String fullTableName, String tableName, String columnName);\n}\n</code></pre>"},{"location":"development/debugging_plugin/","title":"Debugging the Maven Plugin","text":"<p>If you find problems during the code generation with the Maven plugin, take these steps to debug the redg-generator running inside the plugin:</p> <ul> <li>Import the <code>redg</code> project into your IDE (when using IDEA, open in new window)</li> <li>Set your IDE up for remote debugging of the <code>redg</code> project</li> <li>In your other project, add the remote debugging VM options to your Maven profile (<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005</code>)</li> <li>Start the Maven build in the other project</li> <li>Set your breakpoints</li> <li>Attach the remote debugger</li> </ul>"},{"location":"development/quick_start_guide/","title":"Contributing","text":"<p>This is a quick start guide for the development of RedG. If you want to use RedG in your project, see here.</p> <p>Info</p> <p>If you require a feature, either open an issue and hope it might get implemented or feel free to  fork our repository, implement it yourself and create a pull request.</p>"},{"location":"development/quick_start_guide/#project-setup","title":"Project setup","text":"<p>Clone the Git-Repository (<code>git@github.com:yamass/redg.git</code> or your HTTPS link). RedG uses Maven  for development and you can simply import the main <code>pom.xml</code> in your favorite IDE.</p> <p>The main project has 6 sub-projects:</p> Module Content <code>redg-extractor</code> Library for generating RedG entity definition code from existing entities in a database. Can be used for migrating to RedG <code>redg-generator</code> Analyzes the database schema and generates the matching entity classes. Search here if you want to extend or have trouble with the generated code <code>redg-jpa-providers</code> A name and datatype provider for usage with the <code>redg-generator</code>, that uses information from your JPA Metamodel. Not included by default because of Hibernate dependency <code>redg-maven-plugin</code> The plugin that integrates the <code>redg-generator</code> into the Maven build process <code>redg-models</code> Common model files <code>redg-runtime</code> The runtime needed during execution. Search here, if the generated code is fine but execution fails during runtime or you want more features"},{"location":"features/data_extractor/","title":"Data extractor","text":"<p>To help you with migrating from your existing solution to RedG you can use the RedG extractor. It enables you to extract all the data from a database and create a RedG data set that, if inserted, will produce the exact same database content.</p> <p>Note</p> <p>The RedG data set will contain every column from every table. This does not make use of RedG's greatest features (default values, dummy generator). Use the extraction result as a starting point and then reduce your data to the needed minimum. This has to be done by hand, as RedG does not know what data you really need.</p>"},{"location":"features/data_extractor/#java-api","title":"Java API","text":"<p>If you have your current test data only available in-memory during your tests, use the Java API of the extractor to generate the RedG Java code.</p> <p>The generation is a three-step process:</p> <ol> <li>Get the RedG <code>TableModel</code>s for all tables you want to extract</li> <li>Extract all the data into <code>EntityModel</code>s</li> <li>Generate the code for the <code>EntityModel</code>s</li> </ol>"},{"location":"features/data_extractor/#obtain-the-tablemodels","title":"Obtain the TableModels","text":"<p>There are multiple ways of obtaining the <code>TableModel</code>s for your database schema. RedG writes a serialized table model into every generated entity class code.</p> <p>These can be accessed at runtime via the static <code>getTableModel()</code> method. If the generated classes are either not yet compiled or compiled but not loaded in your current JVM instance, you can use the <code>TableModelExtractor.extractTableModelsFromSourceCode(directory, codePackage, classPrefix)</code> or <code>TableModelExtractor.extractTableModelFromClasses(directory, codePackage, classPrefix)</code> methods to extract the <code>TableModel</code>s for all RedG entity classes.</p> <p>These two methods take three parameters:</p> Parameter Explanation <code>directory</code> The <code>Path</code> of the source code root, without the package structure folders <code>packageName</code> The name of the Java package that was used during code generation. <code>de.yamass.redg.generated</code> if not overwritten <code>classPrefix</code> The class name prefix for the generated RedG classes. <code>G</code> by default"},{"location":"features/data_extractor/#extract-all-data","title":"Extract all data","text":"<p>Obtain a connection to your database and call <code>new DataExtractor().extractAllData( connection, tableModels)</code>. <code>tableModels</code> should be the list of <code>TableModel</code>s from the previous step.</p> <p>Note</p> <p>If the database you are extracting from is not the same you generated the RedG code from, you might have to change the schema name. To do so, use <code>DataExtractor#setSqlSchema(String schema)</code> to specify the schema name.</p> <p>Save the result in a list of <code>EntityModel</code>s for the next step.</p> <p>Note</p> <p>If you manually exclude some <code>TableModel</code>s, keep in mind that the extraction will fail if a <code>TableModel</code> for a dependend table (via foreign key) is not found.</p>"},{"location":"features/data_extractor/#generate-the-code","title":"Generate the code","text":"<p>Using the <code>EntityModel</code>s you can now call <code>new CodeGenerator().generateCode( codePackageName, redGClassName, codeClassName, entityModels)</code></p> <p>This will return the Java code as a String. The generated code will be in the default package, so you might need to add your own <code>package x.y.z</code> statement at the top.</p> <p>The <code>generateCode</code> method takes four parameters:</p> Parameter Explanation <code>codePackage</code> The code package of the generated RedG entity classes. Needed for imports <code>redgClassName</code> The name of your RedG main class. Normally <code>RedG</code> <code>className</code> The name that will be used for the class containing your entity specification code <code>entityModels</code> The <code>EntityModel</code>s from the previous step"},{"location":"features/data_extractor/#using-the-generated-code","title":"Using the generated code","text":"<p>When your database only contains strings and numbers, RedG's extractor will most likely produce working Java code. If you are using dates, blobs or other more \"exotic\" types that cannot simply be mapped to a Java type, the <code>toString()</code> result will simply be used as a placeholder and you'll have to fix the code.</p>"},{"location":"features/dummy_data/","title":"Dummy data","text":"<p>RedG's dummy data feature allows you to focus on the test data you really need. No more specifying dozens of (transitive) dependencies you do not need for your test but your database needs them to satisfy the foreign key constraints.</p> <p>With RedG you can simply say \"I want a dummy entity of that type\" and you get one. With all of its dependencies set to other dummy objects. This works out-of-the-box with zero configuration in 99% of the cases.</p> <p>The RedG main class generated by RedG contains a <code>dummyXX</code> method for each entity type.</p>"},{"location":"features/dummy_data/#example","title":"Example","text":"<p>Let's see this in action in a small example. Consider the following database schema:</p> <p></p> <p>Because the user needs a bank account (it is a <code>NOT NULL</code> foreign key), you have to specify a bank account if you want to create a user with the <code>redG.addDemoUser(GDemoBankAccount bankAcc)</code> method. Simply passing <code>null</code> will not work here.</p> <p>If you now want to add a user and perform some tests that only require its first and last name, you can simply use a dummy as the bank account.</p> <pre><code>redG.addDemoUser(redG.dummyBankAccount())\n    .firstName(\"Trevor\")\n    .lastName(\"Testcase\");\n</code></pre> <p>As you can see, RedG does all the heavy work for you. No need to specify anything for the dummy. You get a valid dummy that  satisfies every database constraint so you can test the first and last name without worrying about the excess baggage.</p>"},{"location":"features/dummy_data/#customization","title":"Customization","text":"<p>If you need to customize how RedG generates dummy data, see here.</p>"},{"location":"features/jpa_metamodel/","title":"JPA meta-model analysis","text":"<p>RedG offers the ability to analyze a JPA meta-model and extract the names and data types from there. So if you are using a JPA persistence layer, configuring the names and data types with your existing JPA meta-model might be considerably easier for you.</p>"},{"location":"features/jpa_metamodel/#maven-plugin-configuration","title":"Maven plugin configuration","text":"<p>To use the meta-model analysis with the Maven plugin, add the following XML to the  plugin configuration:</p> <pre><code>&lt;jpaProviderConfig&gt;\n    &lt;persistenceUnitName&gt;nameOfPersistenceUnit&lt;/persistenceUnitName&gt;\n    &lt;useAsNameProvider&gt;true&lt;/useAsNameProvider&gt;\n    &lt;useAsDataTypeProvider&gt;false&lt;/useAsDataTypeProvider&gt;\n&lt;/jpaProviderConfig&gt;\n</code></pre>"},{"location":"features/jpa_metamodel/#java-api","title":"Java API","text":"<p>Create a new <code>JpaMetamodelRedGProvider</code> either with a <code>Metamodel</code> via its constructor or with the static method <code>JpaMetamodelRedGProvider#fromPersistenceUnit(String perstistenceUnitName)</code>. Now use it as the name provider or data type provider as parameter for the RedG code generator method.</p>"},{"location":"features/visualization/","title":"Visualization","text":"<p>The RedG Visualizer allows you to inspect the object graph of a RedG instance. This can be very useful for debugging purposes or to simply have a look at the dependencies of your entities.</p>"},{"location":"features/visualization/#preparation","title":"Preparation","text":"<p>Note</p> <p>RedG's visualization support has to be enabled during code generation time. Look at the documentation for your chosen integration method on how to enable support.</p> <p>Enabling visualization support will have a small performance penalty and you'll need Jackson as extra dependencies.</p> <p>After enabling visualization support you have to add <code>jackson-core</code> and <code>jackson-databind</code> as dependencies to your test code. These two are needed to generate the JSON output you'll need for the visualizer.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.8.5&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.8.5&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Now there are two ways to obtain the entity graph as JSON code:</p> <ul> <li>In the test, output the result of <code>redG.getVisualizationJson()</code> into a file or to the console.</li> <li>Place a breakpoint somewhere in your test where you have access to the <code>redG</code> object, let the test run until   it hits the breakpoint and evaluate <code>redG.getVisualizationJson()</code> with the help of your IDE. Copy the returned string.</li> </ul>"},{"location":"features/visualization/#visualization_1","title":"Visualization","text":"<p>With the JSON output either in your clipboard or a file, visit  the RedG Visualizer site and paste (or drag &amp; drop) the JSON into the editor. Hit the \"Visualize Me!\" button and let the visualization render.</p> <p> An example visualization</p>"},{"location":"features/visualization/#entity-view","title":"Entity view","text":"<p>The main panel of the visualizer shows a graphical representation of your RedG object graph. When the graph is rendered for  the fist time a layout algorithm is applied. This results in a nice initial layout. When visualizing large object graphs, entities may appear below or right of your initial viewport. Either zoom out or pan to see them.</p> Feature Controls Zoom Use your mouse wheel or double click (Pinch or double tap on touchscreens) Pan / Move viewport Click and drag on background (Cursor is default) Select entity Click an entity. Click again to deselect it Move an entity Click and drag an entity (Cursor is pointer)"},{"location":"features/visualization/#detail-view","title":"Detail view","text":"<p>When you select an entity in the entity view, the detail view in the lower right corner will show all attributes (explicit &amp; implicit) in full length and will show a list of all outgoing relations. You can click on a relation link to directly select the referenced entity.</p>"},{"location":"features/visualization/#options","title":"Options","text":"<p>The upper right panel shows the available options and the export buttons.</p> Option Type Explanation Show SQL names Checkbox If checked, the SQL table and column names will be shown instead of the Java identifiers Show relation names Checkbox If checked, the relation arrows will show a text with the relation name Dummy Entity Visibility Combo-Box <ul><li>Full: Show the full dummy entity (explicit &amp; implicit fields)</li><li>Minimal: Show only the header (class / table name)</li><li>Invisible: Do not show the entity and their relations</li></ul> Existing Entity Visibility Combo-Box <ul><li>Full: Show the full existing entity (explicit &amp; implicit fields)</li><li>Minimal: Show only the header (class / table name)</li><li>Invisible: Do not show the entity and their relations</li></ul> Export view as PNG Button Lets you export the current viewport (exactly what you see on the left) to a PNG file. Will show a popup where you can choose the image resolution Export view as SVG Button Lets you export the current viewport (exactly what you see on the left) to a SVG file. All information (entities &amp; relations) are included so you could manipulate the viewport later. Used fonts might not be available on a different computer"},{"location":"integration/","title":"Integration","text":"<p>The way you integrate RedG into you project depends on your build system and personal preferences. RedG is very flexible and can easily be adapted to fit your project.</p>"},{"location":"integration/#redg-code-generator","title":"RedG code generator","text":"<p>The RedG code generator analyzes your database and generates matching entity classes you can then use to specify your test data. Usually the code generation is so fast that it can be run before every test, thus ensuring it is always up-to-date and matches the current database schema. </p> <p>There are multiple ways of integrating the code generator into your project.</p> <ul> <li>The RedG Maven plugin</li> <li>Calling the generator API manually</li> </ul>"},{"location":"integration/#redg-runtime","title":"RedG runtime","text":"<p>The RedG runtime library is available as a Maven dependency in the Maven Central. </p> <p>All of the following integration possibilities require the following dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.yamass.redg&lt;/groupId&gt;\n    &lt;artifactId&gt;redg-runtime&lt;/artifactId&gt;\n    &lt;version&gt;2.0&lt;/version&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>After you have specified your test data you can insert them with the runtime API. This approach offers absolute flexibility and can easily be integrated into any Java project.</p>"},{"location":"integration/generator_api/","title":"Code generator API","text":"<p>When you need every last bit of customizability, using the code generator API is your best option. It offers you one big <code>generateCode</code> method that gives you access to every bit of customization that RedG supports out-of-the-box.</p> <p>To use the API, simply include the following Maven dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;de.yamass.redg&lt;/groupId&gt;\n    &lt;artifactId&gt;redg-generator&lt;/artifactId&gt;\n    &lt;version&gt;2.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>If you use are not using H2, you need to inlcude the JDBC driver and the SchemaCrawler plugin for your DBMS. See here for a list of all supported DBMS and their SchemaCrawler and plugins.</p> <p>See the Javadoc or source code for a detailed description of every parameter of the <code>generateCode</code> method. If you like an example how to use this method, take a look at the  Maven plugin source.</p> <p>If even the standard API is not enough, take a look at the <code>RedGGenerator</code> source code. RedG is pretty modular and every important method is public, so you can just re-use the parts that work for you and re-implement the other parts.</p> <p>If your extension could benefit the community, please consider publishing it and create a pull request.</p>"},{"location":"integration/maven_plugin/","title":"RedG Maven plugin","text":"<p>The RedG Maven plugin offers comfortable and easy integration of the RedG code generation into your  Maven project. It is configurable via Maven properties and JSON files.</p> <p>While the Maven plugin is pretty flexible, RedG can be configured even further if you use the  code generator API directly. If you need absolute control, check out the  docs for the code generator API.</p>"},{"location":"integration/maven_plugin/#usage","title":"Usage","text":"<p>Simply add the RedG plugin into your <code>&lt;plugins&gt;</code> section of your <code>pom.xml</code>. You may choose your own <code>&lt;id&gt;</code>, but the <code>&lt;phase&gt;</code> should stay at <code>generate-test-sources</code> in most cases. Now add your  configuration in the <code>&lt;configuration&gt;</code> part and, if necessary, specify a dependency to your JDBC driver. If you use a different RDBMS than H2 you need an extra dependency to the SchemaCrawler plugin for your DBMS.</p> <p>The list of the most commonly needed plugins (for full list, see in Maven Central):</p> DBMS Necessary dependency Oracle <code>us.fatehi:schemacrawler-oracle:15.01.06</code> IBM DB2 <code>us.fatehi:schemacrawler-db2:15.01.06</code> MS SQL Server <code>us.fatehi:schemacrawler-sqlserver:15.01.06</code> MySQL <code>us.fatehi:schemacrawler-mysql:15.01.06</code> PostgreSQL <code>us.fatehi:schemacrawler-postgresql:15.01.06</code> <pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;de.yamass.redg&lt;/groupId&gt;\n    &lt;artifactId&gt;redg-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;2.0&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;redg-generate&lt;/id&gt;\n            &lt;phase&gt;generate-test-sources&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;redg&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;!-- RedG configuration goes here --&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n    &lt;dependencies&gt;\n        &lt;!-- JDBC driver and SchemaCrawler plugin, only if not using H2. Entry depends on DBMS --&gt;\n    &lt;/dependencies&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"location":"integration/maven_plugin/#configuration","title":"Configuration","text":"<p>The following table lists all configuration options of the RedG Maven plugin.</p> XML Tag Default value Explanation <code>&lt;connectionString&gt;</code> <code>jdbc:h2:mem:redg;DB_CLOSE_DELAY=-1</code> The JDBC connection string for the database that will be analyzed. Uses a H2 in-memory database by default, so if you are using SQL-Scripts, you can omit the connection paramters most of the time. <code>&lt;username&gt;</code> The username for the database.  Can be left unchanged if used with the default connection string. <code>&lt;password&gt;</code> The password for the database user. Can be left unchanged if used with the default connection string. <code>&lt;jdbcDriver&gt;</code> <code>org.h2.Driver</code> The JDBC driver. A Maven dependency providing this class has to be specified if you are not using H2. <code>&lt;sqlScripts&gt;</code> A file array with SQL scripts that should be executed before the database analysis. These scripts can be used to create the schema when you are using an in-memory H2 database. <code>&lt;schemaRegex&gt;</code> <code>.*</code> A regular expression to select all database schemas that will be included in the database analysis. <code>&lt;tablesRegex&gt;</code> <code>.*</code> A regular expression to select all the tables that will be included in the database analysis. If a table is excluded because it belongs to an exlcuded schema, it will not be included again. <code>&lt;outputDirectory&gt;</code> <code>target/generated-test-sources/redg</code> The output folder for the generated source code. Default value is Maven standard. <code>&lt;targetPackage&gt;</code> <code>de.yamass.redg.generated</code> The java package of the to-be-generated entity classes. <code>&lt;classPrefix&gt;</code> <code>G</code> A prefix string that gets prepended to each entity class. <code>&lt;allowPrimitiveTypes&gt;</code> <code>false</code> By default RedG replaces primitive types with their wrapper classes (<code>int</code> to <code>Integer</code>, etc.). Set to <code>true</code> to disable this behavior. <code>&lt;enableVisualizationSupport&gt;</code> <code>false</code> If <code>true</code>, the generated code will support visualization of the object graph <code>&lt;customTypeMappings&gt;</code> A JSON or XML file with custom type mappings. See here for an explanation and an example code. <code>&lt;customNameMappings&gt;</code> A JSON file that defines custom name mappings. See here for an explanation and an example JSON code. <code>&lt;explicitAttributesConfig&gt;</code> A JSON file that defines explicit attributes and foreign keys. See here for an explanation and an example JSON code. <code>&lt;convenienceSetterConfig&gt;</code> A XML file that defines convenience setter methods. See here for an explanation and an example XML code. <code>&lt;jpaProviderConfig&gt;</code> The configuration for the JPA meta-model analysis. See here for an explanation of this feature and example XML. <p>When running maven from the shell, you can use the follwing command line properties to override some configuration values:</p> XML Tag CMD property <code>&lt;connectionString&gt;</code> <code>redg.connectionString</code> <code>&lt;username&gt;</code> <code>redg.username</code> <code>&lt;password&gt;</code> <code>redg.password</code> <code>&lt;jdbcDriver&gt;</code> <code>redg.jdbcDriver</code> <code>&lt;enableVisualizationSupport&gt;</code> <code>redg.enableVisualization</code>"},{"location":"integration/runtime_api/","title":"RedG runtime API","text":"<p>The most bare-bone approach to inserting data with RedG ist the runtime API. Using it directly is the most flexible way and does not require any extra dependencies.</p> <p>The runtime API can be used to either </p> <ul> <li>insert the data set via <code>PreparedStatements</code> into a database using a JDBc <code>Connection</code>.</li> <li>generate SQL <code>INSERT</code> statements that can be used with some other tool (Oracle SqlDeveloper, JetBrains DataGrip, MySQL Workbench, etc.).</li> </ul>"},{"location":"integration/runtime_api/#using-preparedstatements","title":"Using PreparedStatements","text":"<p>To insert the of a RedG instance into a database, call the <code>insertDataIntoDatabase()</code> method and provide a JDBC connection.</p> <p>Note</p> <p>You might need to use a custom  PreparedStatement parameter setter for special data types.</p>"},{"location":"integration/runtime_api/#generating-sql-statements","title":"Generating SQL statements","text":"<p>To generate SQL <code>INSERT</code> statements for your test data, call the <code>generateSQLStatements</code> method on your RedG object. It will return a <code>List&lt;String&gt;</code> with each String being a complete SQL INSERT statement. The list is ordered so that no foreign key constraints are violated, so preserve this order. When exporting the statements into an SQL file you have to append a semicolon to each statement.</p> <p>Note</p> <p>You might need to use a custom  SQL values formatter for special data types.</p> <p>Example code for export:</p> <pre><code>List&lt;String&gt; list = redG.generateSQLStatements();\nString sqlScript = sql.stream().collect(Collectors.joining(\";\\n\"));\n// do whatever you want with sqlScript\n</code></pre>"}]}